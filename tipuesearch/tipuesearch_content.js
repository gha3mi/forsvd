var tipuesearch = {"pages":[{"title":" forsvd ","text":"forsvd ForSVD : A Fortran library for singular value decomposition (SVD) calculation, low-rank approximation, and image compression. fpm dependency If you want to use ForSVD as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] forsvd = { git = \"https://github.com/gha3mi/forsvd.git\" } How to run tests Reuirements: Fortran Compiler, LAPACK or MKL Libraries Clone the repository: You can clone the ForSVD repository from GitHub using the following command: git clone https://github.com/gha3mi/forsvd.git cd forsvd Intel Fortran Compiler (ifort) fpm @ifort-test Intel Fortran Compiler (ifx) fpm @ifx-test GNU Fortran Compiler (gfortran) fpm @gfortran-test NVIDIA Compiler (nvfortran) fpm @nvfortran-test Usage (SVD) use forsvd , only : svd call svd ( A , U , S , VT , method = 'gesvd' ) ! method='gesdd' Example 1 program example1 use kinds use forsvd , only : svd implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , j m = 4 n = 3 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk call svd ( A , U , S , VT ) ! Print U print * , \"U:\" print \"(4F10.6)\" , ( U (:, j ), j = 1 , m ) ! Print S print * , \"S:\" print \"(3F10.6)\" , S ! Print VT print * , \"VT:\" print \"(3F10.6)\" , ( VT (:, j ), j = 1 , n ) deallocate ( A , U , S , VT ) end program example1 Usage (low-rank approximation) use forsvd , only : tsvd call ts % lowrank ( matrix = A , rank = n ) Example 2 program example2 use kinds use forsvd , only : tsvd implicit none real ( rk ), dimension (:,:), allocatable :: A type ( tsvd ) :: ts allocate ( A ( 50 , 20 )) call random_number ( A ) A = A * 10 0.0_rk call ts % lowrank ( matrix = A , rank = 10 ) print * , norm2 ( A - ts % matrix_app ) / norm2 ( A ) call ts % dlloc () end program example2 API documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForSVD using ford run the following\ncommand: ford ford.yml Contributing Contributions to ForSVD are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Developer Info Seyed Ali Ghasemi","tags":"home","loc":"index.html"},{"title":"tsvd – forsvd ","text":"type, public :: tsvd Components Type Visibility Attributes Name Initial real(kind=rk), public, dimension(:,:), allocatable :: matrix real(kind=rk), public, dimension(:,:), allocatable :: matrix_app integer, public :: nrow integer, public :: ncol integer, public :: rank Type-Bound Procedures procedure, public :: lowrank private pure subroutine lowrank (this, matrix, rank, method) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tsvd ), intent(inout) :: this real(kind=rk), intent(in), dimension(:, :) :: matrix integer, intent(in) :: rank character(len=*), intent(in), optional :: method procedure, public :: dlloc => deallocate_tsvd private pure elemental subroutine deallocate_tsvd (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tsvd ), intent(inout) :: this Source Code type :: tsvd real ( rk ), dimension (:,:), allocatable :: matrix real ( rk ), dimension (:,:), allocatable :: matrix_app integer :: nrow , ncol integer :: rank contains procedure :: lowrank procedure :: dlloc => deallocate_tsvd end type tsvd","tags":"","loc":"type/tsvd.html"},{"title":"pixel – forsvd ","text":"type, public :: pixel Components Type Visibility Attributes Name Initial character(len=256), public :: image_name character(len=256), public :: file_name real(kind=rk), public, dimension(:,:), allocatable :: pixels real(kind=rk), public, dimension(:,:), allocatable :: pixels_app integer, public :: nrow integer, public :: ncol integer, public :: rank Type-Bound Procedures procedure, public :: image_to_pixels private impure subroutine image_to_pixels (this, image_name, file_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: image_name character(len=*), intent(in) :: file_name procedure, public :: load_pixels private impure subroutine load_pixels (this, file_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name procedure, public :: compress_pixels private pure subroutine compress_pixels (this, rank, method) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this integer, intent(in) :: rank character(len=*), intent(in), optional :: method procedure, public :: save_pixels private impure subroutine save_pixels (this, file_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name procedure, public :: pixels_to_image private impure subroutine pixels_to_image (this, file_name, image_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=*), intent(in) :: image_name procedure, public :: dlloc => deallocate_pixel private pure elemental subroutine deallocate_pixel (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this Source Code type :: pixel character ( 256 ) :: image_name character ( 256 ) :: file_name real ( rk ), dimension (:,:), allocatable :: pixels real ( rk ), dimension (:,:), allocatable :: pixels_app integer :: nrow , ncol integer :: rank contains procedure :: image_to_pixels ! TODO: procedure :: load_pixels procedure :: compress_pixels procedure :: save_pixels procedure :: pixels_to_image ! TODO: procedure :: dlloc => deallocate_pixel end type pixel","tags":"","loc":"type/pixel.html"},{"title":"svd_rel – forsvd","text":"private pure subroutine svd_rel(A, U, S, VT, method) Calculates the singular value decomposition (SVD) of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(out), dimension(:,:) :: U real(kind=rk), intent(out), dimension(:) :: S real(kind=rk), intent(out), dimension(:,:) :: VT character(len=*), intent(in), optional :: method Calls proc~~svd_rel~~CallsGraph proc~svd_rel forsvd::svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~svd_rel~~CalledByGraph proc~svd_rel forsvd::svd_rel interface~svd forsvd::svd interface~svd->proc~svd_rel proc~lowrank forsvd::tsvd%lowrank proc~lowrank->interface~svd program~benchmark benchmark program~benchmark->interface~svd program~test1 test1 program~test1->interface~svd program~test2 test2 program~test2->interface~svd program~test3 test3 program~test3->interface~svd proc~compress_pixels forsvd::pixel%compress_pixels proc~compress_pixels->proc~lowrank program~test4 test4 program~test4->proc~lowrank program~test5 test5 program~test5->proc~compress_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine svd_rel ( A , U , S , VT , method ) ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension (:,:), intent ( out ) :: U ! Left singular vectors real ( rk ), dimension (:,:), intent ( out ) :: VT ! Right singular vectors real ( rk ), dimension (:), intent ( out ) :: S ! Singular values character ( * ), intent ( in ), optional :: method if (. not . present ( method )) then call gesvd_rel ( A , U , S , VT ) else select case ( method ) case ( 'gesvd' ) call gesvd_rel ( A , U , S , VT ) case ( 'gesdd' ) call gesdd_rel ( A , U , S , VT ) end select end if end subroutine svd_rel","tags":"","loc":"proc/svd_rel.html"},{"title":"gesvd_rel – forsvd","text":"private pure subroutine gesvd_rel(A, U, S, VT) Calculates the singular value decomposition (SVD) of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(out), dimension(:,:) :: U real(kind=rk), intent(out), dimension(:) :: S real(kind=rk), intent(out), dimension(:,:) :: VT Called by proc~~gesvd_rel~~CalledByGraph proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel forsvd::svd_rel proc~svd_rel->proc~gesvd_rel interface~svd forsvd::svd interface~svd->proc~svd_rel proc~lowrank forsvd::tsvd%lowrank proc~lowrank->interface~svd program~benchmark benchmark program~benchmark->interface~svd program~test1 test1 program~test1->interface~svd program~test2 test2 program~test2->interface~svd program~test3 test3 program~test3->interface~svd proc~compress_pixels forsvd::pixel%compress_pixels proc~compress_pixels->proc~lowrank program~test4 test4 program~test4->proc~lowrank program~test5 test5 program~test5->proc~compress_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine gesvd_rel ( A , U , S , VT ) ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension (:,:), intent ( out ) :: U ! Left singular vectors real ( rk ), dimension (:,:), intent ( out ) :: VT ! Right singular vectors real ( rk ), dimension (:), intent ( out ) :: S ! Singular values ! Local variables real ( rk ) :: work1 ( 1 ) ! memory allocation query real ( rk ), dimension (:), allocatable :: work ! Work array integer :: m , n , lwork , info ! External subroutine for calculating the SVD interface dgesvd pure subroutine dgesvd ( jobuf , jobvtf , mf , nf , af , ldaf , sf , uf , lduf , vtf , ldvtf , workf , lworkf , infof ) use kinds character , intent ( in ) :: jobuf , jobvtf integer , intent ( in ) :: mf , nf , ldaf , lduf , ldvtf , lworkf real ( rk ), intent ( in ) :: Af ( ldaf , * ) real ( rk ), intent ( out ) :: Sf ( min ( mf , nf )) real ( rk ), intent ( out ) :: Uf ( lduf , * ), VTf ( ldvtf , * ) real ( rk ), intent ( out ) :: workf ( * ) integer , intent ( out ) :: infof end subroutine dgesvd end interface m = size ( A , 1 ) n = size ( A , 2 ) ! Calculate the optimal size of the work array call dgesvd ( 'S' , 'S' , m , n , A , m , S , U , m , VT , n , work1 , - 1 , info ) lwork = nint ( work1 ( 1 )) allocate ( work ( lwork )) call dgesvd ( 'S' , 'S' , m , n , A , m , S , U , m , VT , n , work , lwork , info ) deallocate ( work ) end subroutine gesvd_rel","tags":"","loc":"proc/gesvd_rel.html"},{"title":"gesdd_rel – forsvd","text":"private pure subroutine gesdd_rel(A, U, S, VT) Calculates the singular value decomposition (SVD) of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(out), dimension(:,:) :: U real(kind=rk), intent(out), dimension(:) :: S real(kind=rk), intent(out), dimension(:,:) :: VT Called by proc~~gesdd_rel~~CalledByGraph proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel forsvd::svd_rel proc~svd_rel->proc~gesdd_rel interface~svd forsvd::svd interface~svd->proc~svd_rel proc~lowrank forsvd::tsvd%lowrank proc~lowrank->interface~svd program~benchmark benchmark program~benchmark->interface~svd program~test1 test1 program~test1->interface~svd program~test2 test2 program~test2->interface~svd program~test3 test3 program~test3->interface~svd proc~compress_pixels forsvd::pixel%compress_pixels proc~compress_pixels->proc~lowrank program~test4 test4 program~test4->proc~lowrank program~test5 test5 program~test5->proc~compress_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine gesdd_rel ( A , U , S , VT ) ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension (:,:), intent ( out ) :: U ! Left singular vectors real ( rk ), dimension (:,:), intent ( out ) :: VT ! Right singular vectors real ( rk ), dimension (:), intent ( out ) :: S ! Singular values ! Local variables real ( rk ) :: work1 ( 1 ) ! memory allocation query real ( rk ), dimension (:), allocatable :: work ! Work array integer :: m , n , lwork , info integer , dimension (:), allocatable :: iwork ! Integer work array ! External subroutine for calculating the SVD interface dgesdd pure subroutine dgesdd ( f_jobz , f_m , f_n , f_a , f_lda , f_s , f_u , f_ldu , f_vt , f_ldvt , f_work , f_lwork , f_iwork , f_info ) use kinds character , intent ( in ) :: f_jobz integer , intent ( in ) :: f_m , f_n , f_lda , f_ldu , f_ldvt , f_lwork real ( rk ), dimension ( f_lda , * ), intent ( in ) :: f_a real ( rk ), dimension ( * ), intent ( out ) :: f_s real ( rk ), dimension ( f_ldu , * ), intent ( out ) :: f_u real ( rk ), dimension ( f_ldvt , * ), intent ( out ) :: f_vt real ( rk ), dimension ( * ), intent ( out ) :: f_work integer , dimension ( * ), intent ( out ) :: f_iwork integer , intent ( out ) :: f_info end subroutine dgesdd end interface m = size ( A , 1 ) n = size ( A , 2 ) allocate ( iwork ( n * 8 )) ! Adjust the size as needed ! Calculate the optimal size of the work array call dgesdd ( 'S' , m , n , A , m , S , U , m , VT , n , work1 , - 1 , iwork , info ) lwork = nint ( work1 ( 1 )) allocate ( work ( lwork )) call dgesdd ( 'S' , m , n , A , m , S , U , m , VT , n , work , lwork , iwork , info ) deallocate ( work ) deallocate ( iwork ) end subroutine gesdd_rel","tags":"","loc":"proc/gesdd_rel.html"},{"title":"lowrank – forsvd","text":"private pure subroutine lowrank(this, matrix, rank, method) Type Bound tsvd Arguments Type Intent Optional Attributes Name class( tsvd ), intent(inout) :: this real(kind=rk), intent(in), dimension(:, :) :: matrix integer, intent(in) :: rank character(len=*), intent(in), optional :: method Calls proc~~lowrank~~CallsGraph proc~lowrank forsvd::tsvd%lowrank interface~svd forsvd::svd proc~lowrank->interface~svd proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lowrank~~CalledByGraph proc~lowrank forsvd::tsvd%lowrank proc~compress_pixels forsvd::pixel%compress_pixels proc~compress_pixels->proc~lowrank program~test4 test4 program~test4->proc~lowrank program~test5 test5 program~test5->proc~compress_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine lowrank ( this , matrix , rank , method ) class ( tsvd ), intent ( inout ) :: this real ( rk ), dimension (:, :), intent ( in ) :: matrix integer , intent ( in ) :: rank character ( * ), intent ( in ), optional :: method real ( rk ), dimension (:, :), allocatable :: U , VT real ( rk ), dimension (:), allocatable :: S integer :: i , j , irank this % matrix = matrix this % nrow = size ( matrix , 1 ) this % ncol = size ( matrix , 2 ) this % rank = rank allocate ( U ( this % nrow , this % nrow ), S ( min ( this % nrow , this % ncol )), VT ( this % ncol , this % ncol )) call svd ( this % matrix , U , S , VT , method ) allocate ( this % matrix_app ( this % nrow , this % ncol )) this % matrix_app = 0.0_rk do irank = 1 , rank do j = 1 , this % ncol do i = 1 , this % nrow this % matrix_app ( i , j ) = this % matrix_app ( i , j ) + U ( i , irank ) * S ( irank ) * VT ( irank , j ) end do end do end do end subroutine lowrank","tags":"","loc":"proc/lowrank.html"},{"title":"image_to_pixels – forsvd","text":"private impure subroutine image_to_pixels(this, image_name, file_name) Type Bound pixel Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: image_name character(len=*), intent(in) :: file_name Called by proc~~image_to_pixels~~CalledByGraph proc~image_to_pixels forsvd::pixel%image_to_pixels program~test5 test5 program~test5->proc~image_to_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine image_to_pixels ( this , image_name , file_name ) class ( pixel ), intent ( inout ) :: this character ( * ), intent ( in ) :: image_name character ( * ), intent ( in ) :: file_name integer :: i , nunit call execute_command_line ( 'python pixel/image_to_pixels.py' ) end subroutine image_to_pixels","tags":"","loc":"proc/image_to_pixels.html"},{"title":"pixels_to_image – forsvd","text":"private impure subroutine pixels_to_image(this, file_name, image_name) Type Bound pixel Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=*), intent(in) :: image_name Called by proc~~pixels_to_image~~CalledByGraph proc~pixels_to_image forsvd::pixel%pixels_to_image program~test5 test5 program~test5->proc~pixels_to_image Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine pixels_to_image ( this , file_name , image_name ) class ( pixel ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name character ( * ), intent ( in ) :: image_name integer :: i , nunit call execute_command_line ( 'python pixel/pixels_to_image.py' ) end subroutine pixels_to_image","tags":"","loc":"proc/pixels_to_image.html"},{"title":"load_pixels – forsvd","text":"private impure subroutine load_pixels(this, file_name) Type Bound pixel Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name Called by proc~~load_pixels~~CalledByGraph proc~load_pixels forsvd::pixel%load_pixels program~test5 test5 program~test5->proc~load_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine load_pixels ( this , file_name ) class ( pixel ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name integer :: i , nunit allocate ( this % pixels ( this % nrow , this % ncol )) open ( newunit = nunit , file = trim ( file_name ), status = 'old' ) do i = 1 , this % nrow read ( nunit , * ) this % pixels ( i , :) end do close ( nunit ) end subroutine load_pixels","tags":"","loc":"proc/load_pixels.html"},{"title":"compress_pixels – forsvd","text":"private pure subroutine compress_pixels(this, rank, method) Type Bound pixel Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this integer, intent(in) :: rank character(len=*), intent(in), optional :: method Calls proc~~compress_pixels~~CallsGraph proc~compress_pixels forsvd::pixel%compress_pixels proc~lowrank forsvd::tsvd%lowrank proc~compress_pixels->proc~lowrank interface~svd forsvd::svd proc~lowrank->interface~svd proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~compress_pixels~~CalledByGraph proc~compress_pixels forsvd::pixel%compress_pixels program~test5 test5 program~test5->proc~compress_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine compress_pixels ( this , rank , method ) class ( pixel ), intent ( inout ) :: this integer , intent ( in ) :: rank character ( * ), intent ( in ), optional :: method type ( tsvd ) :: mat call mat % lowrank ( this % pixels , rank , method ) this % pixels_app = mat % matrix_app end subroutine compress_pixels","tags":"","loc":"proc/compress_pixels.html"},{"title":"save_pixels – forsvd","text":"private impure subroutine save_pixels(this, file_name) Type Bound pixel Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name Called by proc~~save_pixels~~CalledByGraph proc~save_pixels forsvd::pixel%save_pixels program~test5 test5 program~test5->proc~save_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure subroutine save_pixels ( this , file_name ) class ( pixel ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name integer :: i , nunit open ( newunit = nunit , file = trim ( file_name )) do i = 1 , this % nrow write ( nunit , * ) this % pixels_app ( i , :) end do close ( nunit ) end subroutine save_pixels","tags":"","loc":"proc/save_pixels.html"},{"title":"deallocate_pixel – forsvd","text":"private pure elemental subroutine deallocate_pixel(this) Type Bound pixel Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this Called by proc~~deallocate_pixel~~CalledByGraph proc~deallocate_pixel forsvd::pixel%deallocate_pixel program~test5 test5 program~test5->proc~deallocate_pixel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine deallocate_pixel ( this ) class ( pixel ), intent ( inout ) :: this if ( allocated ( this % pixels )) deallocate ( this % pixels ) if ( allocated ( this % pixels_app )) deallocate ( this % pixels_app ) end subroutine deallocate_pixel","tags":"","loc":"proc/deallocate_pixel.html"},{"title":"deallocate_tsvd – forsvd","text":"private pure elemental subroutine deallocate_tsvd(this) Type Bound tsvd Arguments Type Intent Optional Attributes Name class( tsvd ), intent(inout) :: this Called by proc~~deallocate_tsvd~~CalledByGraph proc~deallocate_tsvd forsvd::tsvd%deallocate_tsvd program~test4 test4 program~test4->proc~deallocate_tsvd Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental pure subroutine deallocate_tsvd ( this ) class ( tsvd ), intent ( inout ) :: this if ( allocated ( this % matrix )) deallocate ( this % matrix ) if ( allocated ( this % matrix_app )) deallocate ( this % matrix_app ) end subroutine deallocate_tsvd","tags":"","loc":"proc/deallocate_tsvd.html"},{"title":"svd – forsvd","text":"public interface svd Calls interface~~svd~~CallsGraph interface~svd forsvd::svd proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~svd~~CalledByGraph interface~svd forsvd::svd proc~lowrank forsvd::tsvd%lowrank proc~lowrank->interface~svd program~benchmark benchmark program~benchmark->interface~svd program~test1 test1 program~test1->interface~svd program~test2 test2 program~test2->interface~svd program~test3 test3 program~test3->interface~svd proc~compress_pixels forsvd::pixel%compress_pixels proc~compress_pixels->proc~lowrank program~test4 test4 program~test4->proc~lowrank program~test5 test5 program~test5->proc~compress_pixels Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine svd_rel (A, U, S, VT, method) Author Seyed Ali Ghasemi Calculates the singular value decomposition (SVD) of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(out), dimension(:,:) :: U real(kind=rk), intent(out), dimension(:) :: S real(kind=rk), intent(out), dimension(:,:) :: VT character(len=*), intent(in), optional :: method","tags":"","loc":"interface/svd.html"},{"title":"forsvd – forsvd","text":"Uses kinds module~~forsvd~~UsesGraph module~forsvd forsvd kinds kinds module~forsvd->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~forsvd~~UsedByGraph module~forsvd forsvd program~benchmark benchmark program~benchmark->module~forsvd program~test1 test1 program~test1->module~forsvd program~test2 test2 program~test2->module~forsvd program~test3 test3 program~test3->module~forsvd program~test4 test4 program~test4->module~forsvd program~test5 test5 program~test5->module~forsvd Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface svd private pure subroutine svd_rel (A, U, S, VT, method) Author Seyed Ali Ghasemi Calculates the singular value decomposition (SVD) of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(out), dimension(:,:) :: U real(kind=rk), intent(out), dimension(:) :: S real(kind=rk), intent(out), dimension(:,:) :: VT character(len=*), intent(in), optional :: method Derived Types type, public :: tsvd Components Type Visibility Attributes Name Initial real(kind=rk), public, dimension(:,:), allocatable :: matrix real(kind=rk), public, dimension(:,:), allocatable :: matrix_app integer, public :: nrow integer, public :: ncol integer, public :: rank Type-Bound Procedures procedure, public :: lowrank procedure, public :: dlloc => deallocate_tsvd type, public :: pixel Components Type Visibility Attributes Name Initial character(len=256), public :: image_name character(len=256), public :: file_name real(kind=rk), public, dimension(:,:), allocatable :: pixels real(kind=rk), public, dimension(:,:), allocatable :: pixels_app integer, public :: nrow integer, public :: ncol integer, public :: rank Type-Bound Procedures procedure, public :: image_to_pixels procedure, public :: load_pixels procedure, public :: compress_pixels procedure, public :: save_pixels procedure, public :: pixels_to_image procedure, public :: dlloc => deallocate_pixel Subroutines private pure subroutine svd_rel (A, U, S, VT, method) Author Seyed Ali Ghasemi Calculates the singular value decomposition (SVD) of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(out), dimension(:,:) :: U real(kind=rk), intent(out), dimension(:) :: S real(kind=rk), intent(out), dimension(:,:) :: VT character(len=*), intent(in), optional :: method private pure subroutine gesvd_rel (A, U, S, VT) Author Seyed Ali Ghasemi Calculates the singular value decomposition (SVD) of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(out), dimension(:,:) :: U real(kind=rk), intent(out), dimension(:) :: S real(kind=rk), intent(out), dimension(:,:) :: VT private pure subroutine gesdd_rel (A, U, S, VT) Author Seyed Ali Ghasemi Calculates the singular value decomposition (SVD) of a matrix A. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:, :), contiguous :: A real(kind=rk), intent(out), dimension(:,:) :: U real(kind=rk), intent(out), dimension(:) :: S real(kind=rk), intent(out), dimension(:,:) :: VT private pure subroutine lowrank (this, matrix, rank, method) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tsvd ), intent(inout) :: this real(kind=rk), intent(in), dimension(:, :) :: matrix integer, intent(in) :: rank character(len=*), intent(in), optional :: method private impure subroutine image_to_pixels (this, image_name, file_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: image_name character(len=*), intent(in) :: file_name private impure subroutine pixels_to_image (this, file_name, image_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name character(len=*), intent(in) :: image_name private impure subroutine load_pixels (this, file_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name private pure subroutine compress_pixels (this, rank, method) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this integer, intent(in) :: rank character(len=*), intent(in), optional :: method private impure subroutine save_pixels (this, file_name) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this character(len=*), intent(in) :: file_name private pure elemental subroutine deallocate_pixel (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( pixel ), intent(inout) :: this private pure elemental subroutine deallocate_tsvd (this) Author Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name class( tsvd ), intent(inout) :: this","tags":"","loc":"module/forsvd.html"},{"title":"test4 – forsvd","text":"Uses kinds forsvd program~~test4~~UsesGraph program~test4 test4 kinds kinds program~test4->kinds module~forsvd forsvd program~test4->module~forsvd module~forsvd->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test4~~CallsGraph program~test4 test4 proc~deallocate_tsvd forsvd::tsvd%deallocate_tsvd program~test4->proc~deallocate_tsvd proc~lowrank forsvd::tsvd%lowrank program~test4->proc~lowrank interface~svd forsvd::svd proc~lowrank->interface~svd proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:,:), allocatable :: A type( tsvd ) :: ts Source Code program test4 use kinds use forsvd , only : tsvd implicit none real ( rk ), dimension (:,:), allocatable :: A type ( tsvd ) :: ts allocate ( A ( 50 , 20 )) call random_number ( A ) A = A * 10 0.0_rk call ts % lowrank ( matrix = A , rank = 10 ) print * , norm2 ( A - ts % matrix_app ) / norm2 ( A ) call ts % dlloc () end program test4","tags":"","loc":"program/test4.html"},{"title":"test5 – forsvd","text":"Uses forsvd program~~test5~~UsesGraph program~test5 test5 module~forsvd forsvd program~test5->module~forsvd kinds kinds module~forsvd->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test5~~CallsGraph program~test5 test5 proc~compress_pixels forsvd::pixel%compress_pixels program~test5->proc~compress_pixels proc~deallocate_pixel forsvd::pixel%deallocate_pixel program~test5->proc~deallocate_pixel proc~image_to_pixels forsvd::pixel%image_to_pixels program~test5->proc~image_to_pixels proc~load_pixels forsvd::pixel%load_pixels program~test5->proc~load_pixels proc~pixels_to_image forsvd::pixel%pixels_to_image program~test5->proc~pixels_to_image proc~save_pixels forsvd::pixel%save_pixels program~test5->proc~save_pixels proc~lowrank forsvd::tsvd%lowrank proc~compress_pixels->proc~lowrank interface~svd forsvd::svd proc~lowrank->interface~svd proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial type( pixel ) :: px Source Code program test5 use forsvd , only : pixel implicit none type ( pixel ) :: px px % nrow = 356 px % ncol = 238 call px % image_to_pixels ( image_name = 'pixel/John_W_Backus.jpg' , file_name = 'pixel/John_W_Backus.txt' ) call px % load_pixels ( file_name = 'pixel/John_W_Backus.txt' ) call px % compress_pixels ( rank = 10 ) call px % save_pixels ( file_name = 'pixel/John_W_Backus_com.txt' ) call px % pixels_to_image ( image_name = 'pixel/John_W_Backus.jpg' , file_name = 'pixel/John_W_Backus.txt' ) call px % dlloc () end program test5","tags":"","loc":"program/test5.html"},{"title":"test2 – forsvd","text":"Uses kinds forsvd program~~test2~~UsesGraph program~test2 test2 kinds kinds program~test2->kinds module~forsvd forsvd program~test2->module~forsvd module~forsvd->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test2~~CallsGraph program~test2 test2 interface~svd forsvd::svd program~test2->interface~svd proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:, :), allocatable :: A real(kind=rk), dimension(:, :), allocatable :: U real(kind=rk), dimension(:, :), allocatable :: VT real(kind=rk), dimension(:), allocatable :: S integer :: m integer :: n integer :: i integer :: j Source Code program test2 use kinds use forsvd , only : svd implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , j m = 4 n = 3 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk call svd ( A , U , S , VT , 'gesvd' ) ! Print U print * , \"U:\" print \"(4F10.6)\" , ( U (:, j ), j = 1 , m ) ! Print S print * , \"S:\" print \"(3F10.6)\" , S ! Print VT print * , \"VT:\" print \"(3F10.6)\" , ( VT (:, j ), j = 1 , n ) deallocate ( A , U , S , VT ) end program test2","tags":"","loc":"program/test2.html"},{"title":"test3 – forsvd","text":"Uses kinds forsvd program~~test3~~UsesGraph program~test3 test3 kinds kinds program~test3->kinds module~forsvd forsvd program~test3->module~forsvd module~forsvd->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test3~~CallsGraph program~test3 test3 interface~svd forsvd::svd program~test3->interface~svd proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:, :), allocatable :: A real(kind=rk), dimension(:, :), allocatable :: U real(kind=rk), dimension(:, :), allocatable :: VT real(kind=rk), dimension(:), allocatable :: S integer :: m integer :: n integer :: i integer :: j Source Code program test3 use kinds use forsvd , only : svd implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , j m = 4 n = 3 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk call svd ( A , U , S , VT , 'gesdd' ) ! Print U print * , \"U:\" print \"(4F10.6)\" , ( U (:, j ), j = 1 , m ) ! Print S print * , \"S:\" print \"(3F10.6)\" , S ! Print VT print * , \"VT:\" print \"(3F10.6)\" , ( VT (:, j ), j = 1 , n ) deallocate ( A , U , S , VT ) end program test3","tags":"","loc":"program/test3.html"},{"title":"test1 – forsvd","text":"Uses kinds forsvd program~~test1~~UsesGraph program~test1 test1 kinds kinds program~test1->kinds module~forsvd forsvd program~test1->module~forsvd module~forsvd->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test1~~CallsGraph program~test1 test1 interface~svd forsvd::svd program~test1->interface~svd proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:, :), allocatable :: A real(kind=rk), dimension(:, :), allocatable :: U real(kind=rk), dimension(:, :), allocatable :: VT real(kind=rk), dimension(:), allocatable :: S integer :: m integer :: n integer :: i integer :: j Source Code program test1 use kinds use forsvd , only : svd implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , j m = 4 n = 3 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk call svd ( A , U , S , VT ) ! Print U print * , \"U:\" print \"(4F10.6)\" , ( U (:, j ), j = 1 , m ) ! Print S print * , \"S:\" print \"(3F10.6)\" , S ! Print VT print * , \"VT:\" print \"(3F10.6)\" , ( VT (:, j ), j = 1 , n ) deallocate ( A , U , S , VT ) end program test1","tags":"","loc":"program/test1.html"},{"title":"benchmark – forsvd","text":"Uses kinds forsvd fortime program~~benchmark~~UsesGraph program~benchmark benchmark fortime fortime program~benchmark->fortime kinds kinds program~benchmark->kinds module~forsvd forsvd program~benchmark->module~forsvd module~forsvd->kinds Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~benchmark~~CallsGraph program~benchmark benchmark interface~svd forsvd::svd program~benchmark->interface~svd timer_start timer_start program~benchmark->timer_start timer_stop timer_stop program~benchmark->timer_stop proc~svd_rel forsvd::svd_rel interface~svd->proc~svd_rel proc~gesdd_rel forsvd::gesdd_rel proc~svd_rel->proc~gesdd_rel proc~gesvd_rel forsvd::gesvd_rel proc~svd_rel->proc~gesvd_rel Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk), dimension(:, :), allocatable :: A real(kind=rk), dimension(:, :), allocatable :: U real(kind=rk), dimension(:, :), allocatable :: VT real(kind=rk), dimension(:), allocatable :: S integer :: m integer :: n integer :: i integer :: ntests type(timer) :: t Source Code program benchmark use kinds use forsvd , only : svd use fortime , only : timer implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , ntests type ( timer ) :: t m = 1000 n = 1000 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk ntests = 5 call t % timer_start () do i = 1 , ntests call svd ( A , U , S , VT , 'gesvd' ) end do call t % timer_stop ( nloops = ntests , message = 'Elapsed time (gesvd): ' ) call t % timer_start () do i = 1 , ntests call svd ( A , U , S , VT , 'gesdd' ) end do call t % timer_stop ( nloops = ntests , message = 'Elapsed time (gesdd): ' ) deallocate ( A , U , S , VT ) end program benchmark","tags":"","loc":"program/benchmark.html"},{"title":"test4.f90 – forsvd","text":"This file depends on sourcefile~~test4.f90~~EfferentGraph sourcefile~test4.f90 test4.f90 sourcefile~forsvd.f90 forsvd.f90 sourcefile~test4.f90->sourcefile~forsvd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test4 use kinds use forsvd , only : tsvd implicit none real ( rk ), dimension (:,:), allocatable :: A type ( tsvd ) :: ts allocate ( A ( 50 , 20 )) call random_number ( A ) A = A * 10 0.0_rk call ts % lowrank ( matrix = A , rank = 10 ) print * , norm2 ( A - ts % matrix_app ) / norm2 ( A ) call ts % dlloc () end program test4","tags":"","loc":"sourcefile/test4.f90.html"},{"title":"test5.f90 – forsvd","text":"This file depends on sourcefile~~test5.f90~~EfferentGraph sourcefile~test5.f90 test5.f90 sourcefile~forsvd.f90 forsvd.f90 sourcefile~test5.f90->sourcefile~forsvd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test5 use forsvd , only : pixel implicit none type ( pixel ) :: px px % nrow = 356 px % ncol = 238 call px % image_to_pixels ( image_name = 'pixel/John_W_Backus.jpg' , file_name = 'pixel/John_W_Backus.txt' ) call px % load_pixels ( file_name = 'pixel/John_W_Backus.txt' ) call px % compress_pixels ( rank = 10 ) call px % save_pixels ( file_name = 'pixel/John_W_Backus_com.txt' ) call px % pixels_to_image ( image_name = 'pixel/John_W_Backus.jpg' , file_name = 'pixel/John_W_Backus.txt' ) call px % dlloc () end program test5","tags":"","loc":"sourcefile/test5.f90.html"},{"title":"forsvd.f90 – forsvd","text":"Files dependent on this one sourcefile~~forsvd.f90~~AfferentGraph sourcefile~forsvd.f90 forsvd.f90 sourcefile~benchmark.f90 benchmark.f90 sourcefile~benchmark.f90->sourcefile~forsvd.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~forsvd.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~forsvd.f90 sourcefile~test3.f90 test3.f90 sourcefile~test3.f90->sourcefile~forsvd.f90 sourcefile~test4.f90 test4.f90 sourcefile~test4.f90->sourcefile~forsvd.f90 sourcefile~test5.f90 test5.f90 sourcefile~test5.f90->sourcefile~forsvd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module forsvd ! This module provides functions and subroutines ! for calculating the singular value decomposition (SVD). use kinds implicit none private public :: svd , tsvd , pixel !=============================================================================== type :: tsvd real ( rk ), dimension (:,:), allocatable :: matrix real ( rk ), dimension (:,:), allocatable :: matrix_app integer :: nrow , ncol integer :: rank contains procedure :: lowrank procedure :: dlloc => deallocate_tsvd end type tsvd !=============================================================================== !=============================================================================== type :: pixel character ( 256 ) :: image_name character ( 256 ) :: file_name real ( rk ), dimension (:,:), allocatable :: pixels real ( rk ), dimension (:,:), allocatable :: pixels_app integer :: nrow , ncol integer :: rank contains procedure :: image_to_pixels ! TODO: procedure :: load_pixels procedure :: compress_pixels procedure :: save_pixels procedure :: pixels_to_image ! TODO: procedure :: dlloc => deallocate_pixel end type pixel !=============================================================================== !=============================================================================== interface svd procedure :: svd_rel ! Interface for the svd_rel subroutine end interface !=============================================================================== contains !=============================================================================== !> author: Seyed Ali Ghasemi !> Calculates the singular value decomposition (SVD) of a matrix A. pure subroutine svd_rel ( A , U , S , VT , method ) ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension (:,:), intent ( out ) :: U ! Left singular vectors real ( rk ), dimension (:,:), intent ( out ) :: VT ! Right singular vectors real ( rk ), dimension (:), intent ( out ) :: S ! Singular values character ( * ), intent ( in ), optional :: method if (. not . present ( method )) then call gesvd_rel ( A , U , S , VT ) else select case ( method ) case ( 'gesvd' ) call gesvd_rel ( A , U , S , VT ) case ( 'gesdd' ) call gesdd_rel ( A , U , S , VT ) end select end if end subroutine svd_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Calculates the singular value decomposition (SVD) of a matrix A. pure subroutine gesvd_rel ( A , U , S , VT ) ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension (:,:), intent ( out ) :: U ! Left singular vectors real ( rk ), dimension (:,:), intent ( out ) :: VT ! Right singular vectors real ( rk ), dimension (:), intent ( out ) :: S ! Singular values ! Local variables real ( rk ) :: work1 ( 1 ) ! memory allocation query real ( rk ), dimension (:), allocatable :: work ! Work array integer :: m , n , lwork , info ! External subroutine for calculating the SVD interface dgesvd pure subroutine dgesvd ( jobuf , jobvtf , mf , nf , af , ldaf , sf , uf , lduf , vtf , ldvtf , workf , lworkf , infof ) use kinds character , intent ( in ) :: jobuf , jobvtf integer , intent ( in ) :: mf , nf , ldaf , lduf , ldvtf , lworkf real ( rk ), intent ( in ) :: Af ( ldaf , * ) real ( rk ), intent ( out ) :: Sf ( min ( mf , nf )) real ( rk ), intent ( out ) :: Uf ( lduf , * ), VTf ( ldvtf , * ) real ( rk ), intent ( out ) :: workf ( * ) integer , intent ( out ) :: infof end subroutine dgesvd end interface m = size ( A , 1 ) n = size ( A , 2 ) ! Calculate the optimal size of the work array call dgesvd ( 'S' , 'S' , m , n , A , m , S , U , m , VT , n , work1 , - 1 , info ) lwork = nint ( work1 ( 1 )) allocate ( work ( lwork )) call dgesvd ( 'S' , 'S' , m , n , A , m , S , U , m , VT , n , work , lwork , info ) deallocate ( work ) end subroutine gesvd_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi !> Calculates the singular value decomposition (SVD) of a matrix A. pure subroutine gesdd_rel ( A , U , S , VT ) ! Inputs: real ( rk ), dimension (:, :), contiguous , intent ( in ) :: A ! Input matrix A ! Outputs: real ( rk ), dimension (:,:), intent ( out ) :: U ! Left singular vectors real ( rk ), dimension (:,:), intent ( out ) :: VT ! Right singular vectors real ( rk ), dimension (:), intent ( out ) :: S ! Singular values ! Local variables real ( rk ) :: work1 ( 1 ) ! memory allocation query real ( rk ), dimension (:), allocatable :: work ! Work array integer :: m , n , lwork , info integer , dimension (:), allocatable :: iwork ! Integer work array ! External subroutine for calculating the SVD interface dgesdd pure subroutine dgesdd ( f_jobz , f_m , f_n , f_a , f_lda , f_s , f_u , f_ldu , f_vt , f_ldvt , f_work , f_lwork , f_iwork , f_info ) use kinds character , intent ( in ) :: f_jobz integer , intent ( in ) :: f_m , f_n , f_lda , f_ldu , f_ldvt , f_lwork real ( rk ), dimension ( f_lda , * ), intent ( in ) :: f_a real ( rk ), dimension ( * ), intent ( out ) :: f_s real ( rk ), dimension ( f_ldu , * ), intent ( out ) :: f_u real ( rk ), dimension ( f_ldvt , * ), intent ( out ) :: f_vt real ( rk ), dimension ( * ), intent ( out ) :: f_work integer , dimension ( * ), intent ( out ) :: f_iwork integer , intent ( out ) :: f_info end subroutine dgesdd end interface m = size ( A , 1 ) n = size ( A , 2 ) allocate ( iwork ( n * 8 )) ! Adjust the size as needed ! Calculate the optimal size of the work array call dgesdd ( 'S' , m , n , A , m , S , U , m , VT , n , work1 , - 1 , iwork , info ) lwork = nint ( work1 ( 1 )) allocate ( work ( lwork )) call dgesdd ( 'S' , m , n , A , m , S , U , m , VT , n , work , lwork , iwork , info ) deallocate ( work ) deallocate ( iwork ) end subroutine gesdd_rel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine lowrank ( this , matrix , rank , method ) class ( tsvd ), intent ( inout ) :: this real ( rk ), dimension (:, :), intent ( in ) :: matrix integer , intent ( in ) :: rank character ( * ), intent ( in ), optional :: method real ( rk ), dimension (:, :), allocatable :: U , VT real ( rk ), dimension (:), allocatable :: S integer :: i , j , irank this % matrix = matrix this % nrow = size ( matrix , 1 ) this % ncol = size ( matrix , 2 ) this % rank = rank allocate ( U ( this % nrow , this % nrow ), S ( min ( this % nrow , this % ncol )), VT ( this % ncol , this % ncol )) call svd ( this % matrix , U , S , VT , method ) allocate ( this % matrix_app ( this % nrow , this % ncol )) this % matrix_app = 0.0_rk do irank = 1 , rank do j = 1 , this % ncol do i = 1 , this % nrow this % matrix_app ( i , j ) = this % matrix_app ( i , j ) + U ( i , irank ) * S ( irank ) * VT ( irank , j ) end do end do end do end subroutine lowrank !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi ! TODO: impure subroutine image_to_pixels ( this , image_name , file_name ) class ( pixel ), intent ( inout ) :: this character ( * ), intent ( in ) :: image_name character ( * ), intent ( in ) :: file_name integer :: i , nunit call execute_command_line ( 'python pixel/image_to_pixels.py' ) end subroutine image_to_pixels !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi ! TODO: impure subroutine pixels_to_image ( this , file_name , image_name ) class ( pixel ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name character ( * ), intent ( in ) :: image_name integer :: i , nunit call execute_command_line ( 'python pixel/pixels_to_image.py' ) end subroutine pixels_to_image !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine load_pixels ( this , file_name ) class ( pixel ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name integer :: i , nunit allocate ( this % pixels ( this % nrow , this % ncol )) open ( newunit = nunit , file = trim ( file_name ), status = 'old' ) do i = 1 , this % nrow read ( nunit , * ) this % pixels ( i , :) end do close ( nunit ) end subroutine load_pixels !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi pure subroutine compress_pixels ( this , rank , method ) class ( pixel ), intent ( inout ) :: this integer , intent ( in ) :: rank character ( * ), intent ( in ), optional :: method type ( tsvd ) :: mat call mat % lowrank ( this % pixels , rank , method ) this % pixels_app = mat % matrix_app end subroutine compress_pixels !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi impure subroutine save_pixels ( this , file_name ) class ( pixel ), intent ( inout ) :: this character ( * ), intent ( in ) :: file_name integer :: i , nunit open ( newunit = nunit , file = trim ( file_name )) do i = 1 , this % nrow write ( nunit , * ) this % pixels_app ( i , :) end do close ( nunit ) end subroutine save_pixels !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine deallocate_pixel ( this ) class ( pixel ), intent ( inout ) :: this if ( allocated ( this % pixels )) deallocate ( this % pixels ) if ( allocated ( this % pixels_app )) deallocate ( this % pixels_app ) end subroutine deallocate_pixel !=============================================================================== !=============================================================================== !> author: Seyed Ali Ghasemi elemental pure subroutine deallocate_tsvd ( this ) class ( tsvd ), intent ( inout ) :: this if ( allocated ( this % matrix )) deallocate ( this % matrix ) if ( allocated ( this % matrix_app )) deallocate ( this % matrix_app ) end subroutine deallocate_tsvd !=============================================================================== end module forsvd","tags":"","loc":"sourcefile/forsvd.f90.html"},{"title":"test2.f90 – forsvd","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~forsvd.f90 forsvd.f90 sourcefile~test2.f90->sourcefile~forsvd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test2 use kinds use forsvd , only : svd implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , j m = 4 n = 3 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk call svd ( A , U , S , VT , 'gesvd' ) ! Print U print * , \"U:\" print \"(4F10.6)\" , ( U (:, j ), j = 1 , m ) ! Print S print * , \"S:\" print \"(3F10.6)\" , S ! Print VT print * , \"VT:\" print \"(3F10.6)\" , ( VT (:, j ), j = 1 , n ) deallocate ( A , U , S , VT ) end program test2","tags":"","loc":"sourcefile/test2.f90.html"},{"title":"test3.f90 – forsvd","text":"This file depends on sourcefile~~test3.f90~~EfferentGraph sourcefile~test3.f90 test3.f90 sourcefile~forsvd.f90 forsvd.f90 sourcefile~test3.f90->sourcefile~forsvd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test3 use kinds use forsvd , only : svd implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , j m = 4 n = 3 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk call svd ( A , U , S , VT , 'gesdd' ) ! Print U print * , \"U:\" print \"(4F10.6)\" , ( U (:, j ), j = 1 , m ) ! Print S print * , \"S:\" print \"(3F10.6)\" , S ! Print VT print * , \"VT:\" print \"(3F10.6)\" , ( VT (:, j ), j = 1 , n ) deallocate ( A , U , S , VT ) end program test3","tags":"","loc":"sourcefile/test3.f90.html"},{"title":"test1.f90 – forsvd","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~forsvd.f90 forsvd.f90 sourcefile~test1.f90->sourcefile~forsvd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test1 use kinds use forsvd , only : svd implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , j m = 4 n = 3 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk call svd ( A , U , S , VT ) ! Print U print * , \"U:\" print \"(4F10.6)\" , ( U (:, j ), j = 1 , m ) ! Print S print * , \"S:\" print \"(3F10.6)\" , S ! Print VT print * , \"VT:\" print \"(3F10.6)\" , ( VT (:, j ), j = 1 , n ) deallocate ( A , U , S , VT ) end program test1","tags":"","loc":"sourcefile/test1.f90.html"},{"title":"benchmark.f90 – forsvd","text":"This file depends on sourcefile~~benchmark.f90~~EfferentGraph sourcefile~benchmark.f90 benchmark.f90 sourcefile~forsvd.f90 forsvd.f90 sourcefile~benchmark.f90->sourcefile~forsvd.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program benchmark use kinds use forsvd , only : svd use fortime , only : timer implicit none real ( rk ), dimension (:, :), allocatable :: A , U , VT real ( rk ), dimension (:), allocatable :: S integer :: m , n , i , ntests type ( timer ) :: t m = 1000 n = 1000 allocate ( A ( m , n ), U ( m , m ), S ( min ( m , n )), VT ( n , n )) call random_number ( A ) A = A * 1 0.0_rk ntests = 5 call t % timer_start () do i = 1 , ntests call svd ( A , U , S , VT , 'gesvd' ) end do call t % timer_stop ( nloops = ntests , message = 'Elapsed time (gesvd): ' ) call t % timer_start () do i = 1 , ntests call svd ( A , U , S , VT , 'gesdd' ) end do call t % timer_stop ( nloops = ntests , message = 'Elapsed time (gesdd): ' ) deallocate ( A , U , S , VT ) end program benchmark","tags":"","loc":"sourcefile/benchmark.f90.html"}]}